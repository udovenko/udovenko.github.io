---
layout: post
title:  "Using dynamic imports with old versions of React on Rails"
date:   2018-03-26 11:16:01 +1100
---

> At the moment of writing this post, [React on Rails gem](https://github.com/shakacode/react_on_rails) has an integration with [Webpacker](https://github.com/rails/webpacker) and should work fine with [Webpack dynamic imports](https://webpack.js.org/guides/code-splitting/#dynamic-imports) so if you are able to swith to the lates version of **React on Rails** - just go ahead, follow gem's official docs and skip this article.

### The History

But if you're still here and reading this, let's return few years back, to the moment when **React on Rails** was using [Rails Asset Pipeline](http://guides.rubyonrails.org/asset_pipeline.html) to fingerprint bundles generated by **Webpack** by including them to regular **Sprockets's** *application.js* and *application.css* files.

> For clarity lets imagine that the version of **React on Rails** on that moment was 6.10.0. I will give all links to the gem's docs under that particular tag.

Why would you use that old version? Well, usually it can happen when you are clocked by some other old gems that produce dependency conflict with newer versions of **React on Rails** or you're simply use old version of **Rails** itself.

Here's how it was actually working:
1. **Webpack** was building **JS** and **CSS** the bundles to *app/assets/webpack* directory. Bundle files should have been named without any hashing by **Webpack**, like *client-bundle.js* and so on.
2. Those bundles were referenced in *app/assets/javascripts/application.js* by direcrtives like `//= require client-bundle` (and something like `@import 'client-bundle';` in *app/assets/stylesheets/application.scss*).
3. In **staging** environments these files were loading to the page by referencing them according to real names. **Asset Pipeline** was simply generating tags like `<script src="assets/client-bundle.js"></script>` and similar for **CCS**.
4. In **production** environments all scripts included in *app/assets/javascripts/application.js* were combined in in single file, compressed by **Uglifier** (or whatever else was set as a **JS** compiler), hashed according that file's **MD5** sum. As a result in production we were getting something like `<script src="/assets/application-908e25f4bf641868d8683022a5b62f54.js"></script>`. Something very similar was happening with **CSS** bundles, created by **Webpack**.

At point **3** and **4** I'm tending to repeat **Asset Pipeline** docs, which I generally don't like to do. So if you need some details about how all these works - just check official docs and [Sprockets](https://github.com/rails/sprockets) repo. There is also a pretty good explanation of what I'm trying to describe in old [README form React on Rails repo](https://github.com/shakacode/react_on_rails/tree/6.10.0#how-it-works).

### The Problem

Everything described above was working just fine if using **Dynamic Imports** was not the case.

At the time where we traveled to in previous section (few years ago), the version of **Webpack** was **1.x** or **2.x** and
we used `require.ensure()` construction instead of `import()` syntax to dynamically load code chunks. Let's mean both syntaxes by **Dynamic Imports** for clarity - they intended to do about the same thing.

So what's the actually problem? The problem is that in our particular case both **Webpack** and **Asset Pipeline** interfere each other trying to solve the same problem - bypassing browser's cache when sorce files were updated.

When **Webpack** builds the **entry** chunk that is responsible for dynamic loading of **children** (the chunks created by analyzing your split points i.e. `require.ensure()`), it embeds **children** chunk names into the result code. It means that **entry** chunk expects particular file to be available in your `config.output.publicPath`.

On the other hand, when files go through **Assets Pipeline** in production, their names change by adding **MD5** hashes. Which means **entry** chunk will unable to find **children** since they were renamed.

### An "official" solution

Of course [Shakacode team](http://www.shakacode.com/) (creators and maintainers of the gem) was aware of everything I've just explained above. Even in early versions of **React on Rails** repo you can find good document about [code splitting](https://github.com/shakacode/react_on_rails/blob/6.10.0/docs/additional-reading/code-splitting.md) that describes the feature in details.

And they also offered a general [solution to double "digesting" problem](https://github.com/shakacode/react_on_rails/blob/6.10.0/docs/additional-reading/rails-assets.md). In short, they offer to symlink chunk names created by **Webpack** to files created during assets precompilation by **Asset Pipeline** in a special **rake** task. I worth mention that in this case **Webpack** files must be precompiles separately instead of joining them into single *app/assets/javascripts/application.js* file (same for **CSS**).

I was pretty unhappy with proposed approach. My main concerns were:
1. In order to bypass browser cache when code in **children** chunks was changed I was needed to generate them under unique hashed name using `[chunkhash]` substitution in **Webppack's** `output.filename`. **Webpack** provides that functionality right from the first versions so why do I need **Asset Pipeline** to add its own digest to the files?
2. **Weback** also was offering its own [UglifyJsPlugin](https://github.com/webpack-contrib/uglifyjs-webpack-plugin) that was capable of taking **Uglifier** gem responsibilities right during bundling by **Webpack**. So why should we bundle **JS** files with **Webpack** but compress them with other technology?
3. There were good plugins like [StatsWriterPlugin](https://github.com/FormidableLabs/webpack-stats-plugin) for writing manifest file in order to map chunk names to their hashed versions generated during **Webpack** build. Isn't it the same as what **Asset Pipeline** actually does to map initial asset names to "digested" ones?

So **Webpack** was capable to completely replace **Asset Pipeline**. That's actually why **Webpacker** gem was introduced later on. Also extra step with sending chunks over **Asset Pipeline** and double "digesting" them was blowing my and my colleagues mind. That's why I decided to come up with my own solution.

### My solution

My general idea was to build **Webpack** bundle directly to *public/assets* directory. **Rails** can serve static  assets itself, as well as **Nginx** or other servers/proxy that are used in the wild.

First of all I was needed to ensure that **JS** chunks created by **Webpack** have unique name for every code update in production. On the other hand, it was not necessary in development. So I had to use some *ENV* variable to determine how to name chunk files. And *NODE_ENV* was pretty suitable for this purpose. Let's say `config` is our **Webpack** configuration object:

```javascript
if (process.env.NODE_ENV == 'production') {
  ...
  config.output.filename = '[name]-bundle-[chunkhash].js';
  config.output.chunkFilename = '[name]-bundle-[chunkhash].js';
} else {
  ...
  config.output.filename = '[name]-bundle.js';
  config.output.chunkFilename = '[name]-bundle.js';
}
```

And we have to set `output` to *public/assets* instead of *app/assets/webpack*:

```javascript
...
config.output = { path: path.resolve(__dirname, '../public/assets') };
```
So now `webpack --config [our.config.js]` will build our bundle without hashes in chunk names while `NODE_ENV=production webpack --config [our.config.js]` will produce chunks with hashed names like *posts-bundle-17730bdaad90d923e32a.js*.

After that I was needed to implement **JS** compression for production. It was pretty easy:

```javascript
config.plugins.push(
  new webpack.optimize.UglifyJsPlugin({
    compress: { warnings: false },
  })
);
```
