---
layout: post
title:  "Using dynamic imports with old versions of React on Rails"
date:   2018-03-26 11:16:01 +1100
---

> At the moment of writing this post, [React on Rails gem](https://github.com/shakacode/react_on_rails) has an integration with [Webpacker](https://github.com/rails/webpacker) and should work fine with [Webpack dynamic imports](https://webpack.js.org/guides/code-splitting/#dynamic-imports) as well as with assets created by [Webpack file-loader](https://webpack.js.org/loaders/file-loader/) so if you are able to switch to the latest version of **React on Rails** - just go ahead, follow gem's official docs and skip this article.

## The History

But if you're still here and reading this, let's return few years back, to the moment when **React on Rails** was using [Rails Asset Pipeline](http://guides.rubyonrails.org/asset_pipeline.html) by including bundles generated by **Webpack** to regular **Sprockets's** *application.js* and *application.css* files (or precompiling them separately).

> For clarity lets imagine that the version of **React on Rails** on that moment was 6.10.0. I will give all links to the gem's docs under that particular tag.

Why would you use that old version? Well, usually it can happen when you are clocked by some other old gems that produce dependency conflict with newer versions of **React on Rails** or you're simply use old version of **Rails** itself.

> Also for clarity lets recall what these **Webpack**-specific words like **bundle** or **chunk** mean. According to the [glossary](https://webpack.js.org/glossary/):
- **chunk** - Webpack-specific term is used internally to manage the bundling process. Bundles are composed out of chunks, of which there are several types (e.g. entry and child). Typically, chunks directly correspond with the output bundles however, there are some configurations that don't yield a one-to-one relationship.
- **bundle** - Produced from a number of distinct modules, bundles contain the final versions of source files that have already undergone the loading and compilation process.

Here's how old **React on Rails** was actually working:
1. **Webpack** was building **JS** and **CSS** the bundles to *app/assets/webpack* directory. Bundle files should have been named without any hashing by **Webpack**, like *client-bundle.js* and so on.
2. Those bundles were referenced in *app/assets/javascripts/application.js* by direcrtives like `//= require client-bundle` (and something like `@import 'client-bundle';` in *app/assets/stylesheets/application.scss*) or precompiled directly by **Asset Pipeline** if they were added to `Rails.application.config.assets.precompile` array.
3. In **staging** environments these files were loading to the page by referencing them according to real names. **Asset Pipeline** was simply generating tags like `<script src="assets/client-bundle.js"></script>` and similar for **CCS**.
4. In **production** environments all scripts included in *app/assets/javascripts/application.js* were combined in in single file (or precompiled separately), compressed by **Uglifier** (or whatever else was set as a **JS** compiler), hashed according that file's **MD5** sum. As a result in production we were getting something like `<script src="/assets/application-908e25f4bf641868d8683022a5b62f54.js"></script>`. Something very similar was happening with **CSS** bundles, created by **Webpack**.

At point **3** and **4** I'm tending to repeat **Asset Pipeline** docs, which I generally don't like to do. So if you need some details about how all these works - just check official docs and [Sprockets](https://github.com/rails/sprockets) repo. There is also a pretty good explanation of what I'm trying to describe in old [README form React on Rails repo](https://github.com/shakacode/react_on_rails/tree/6.10.0#how-it-works).

## The Problem

Everything described above was working just fine if using **Dynamic Imports** and **Webpack file loader** was not the case.

At the time where we traveled to in previous section (few years ago), the version of **Webpack** was **1.x** or **2.x** and
we used `require.ensure()` construction instead of `import()` syntax to dynamically load code chunks. Let's mean both syntaxes by **Dynamic Imports** for clarity - they intended to do about the same thing.

So what's the actually problem? The problem is that everything goes through the **Asset Pipeline** and get double "digested" while **Webpack** is able to do all this job itself .

When **Webpack** builds the **entry** chunk that is responsible for dynamic loading of **children** (the chunks created by analyzing your split points i.e. `require.ensure()`), it embeds **children** chunk names into the result code. It means that **entry** chunk expects particular file to be available in your `config.output.publicPath`.

On the other hand, when files go through **Assets Pipeline** in production, their names change by adding **MD5** hashes. Which means **entry** chunk will unable to find **children** since they were renamed.

About the same thing happens to images generated by **Webpack file-loader**.

## The "official" solution

Of course [Shakacode team](http://www.shakacode.com/) (creators and maintainers of the gem) was aware of everything I've just explained above. Even in early versions of **React on Rails** repo you can find good document about [code splitting](https://github.com/shakacode/react_on_rails/blob/6.10.0/docs/additional-reading/code-splitting.md) that describes the feature in details.

And they also offered a general [solution to double "digesting" problem](https://github.com/shakacode/react_on_rails/blob/6.10.0/docs/additional-reading/rails-assets.md). In short, they offer to symlink names of bundles and other assets generated by **Webpack** to files created from them during assets precompilation by **Asset Pipeline** in a special **rake** task. I worth mention that in this case **Webpack** files must be precompiled separately instead of joining them into single *app/assets/javascripts/application.js* file (same for **CSS**).

I was pretty unhappy with proposed approach. My main concerns were:
1. In order to bypass browser cache when code in **children** chunks was changed I was needed to generate them under unique hashed name using `[chunkhash]` substitution in **Webppack's** `output.filename`. **Webpack** provides that functionality right from the first versions so why do I need **Asset Pipeline** to add its own digest to the files?
2. **Weback** also was offering its own [UglifyJsPlugin](https://github.com/webpack-contrib/uglifyjs-webpack-plugin) that was capable of taking **Uglifier** gem responsibilities right during bundling by **Webpack**. So why should we bundle **JS** files with **Webpack** but compress them with other technology?
3. There were good plugins like [StatsWriterPlugin](https://github.com/FormidableLabs/webpack-stats-plugin) for writing manifest file in order to map chunk names to their hashed versions generated during **Webpack** build. Isn't it the same as what **Asset Pipeline** actually does to map initial asset names to "digested" ones?

So **Webpack** was capable to completely replace **Asset Pipeline**. That's actually why **Webpacker** gem was introduced later on. This extra step with sending bundles over **Asset Pipeline** and double "digesting" them was simply blowing my and my colleagues mind. That's why I decided to come up with my own solution.

## The custom solution

My general idea was to build **Webpack** bundle directly to *public/assets* directory. **Rails** can serve static  assets itself, as well as **Nginx** or other servers/proxy that are used in the wild.

### Building chunks directly to public directory

First of all I was needed to ensure that **JS** chunks created by **Webpack** have unique name for every code update in production. On the other hand, it was not necessary in development. So I had to use some *ENV* variable to determine how to name chunk files. And *NODE_ENV* was pretty suitable for this purpose. Let's say `config` is our **Webpack** configuration object:

```javascript
if (process.env.NODE_ENV == 'production') {
  ...
  config.output.filename = '[name]-bundle-[chunkhash].js';
  config.output.chunkFilename = '[name]-bundle-[chunkhash].js';
} else {
  ...
  config.output.filename = '[name]-bundle.js';
  config.output.chunkFilename = '[name]-bundle.js';
}
```

And we have to set `output` to *public/assets* instead of *app/assets/webpack*:

```javascript
...
config.output = { path: path.resolve(__dirname, '../public/assets') };
```
So now `webpack --config [our.config.js]` will build our bundles without hashes in names while `NODE_ENV=production webpack --config [our.config.js]` will produce bundles with hashed names like *posts-bundle-17730bdaad90d923e32a.js*.

If you use [server rendering](https://github.com/shakacode/react_on_rails/tree/6.10.0#client-side-rendering-vs-server-side-rendering) in your project, you also need to generate your server bundle to *public/assets* because **React on Rails** looks for all bundles in the same folder.

To let the gem know where to look for generated bundles we need to update its initializer:

```ruby
ReactOnRails.configure do |config|
  ...
  config.generated_assets_dir = File.join(%w[public assets])
end
```

### Adding JS compression by Webpack

That was easy enough. Assuming `config.plugins` already is an array of some plugins:

```javascript
if (process.env.NODE_ENV == 'production') {
  ...
  config.plugins.push(
    new webpack.optimize.UglifyJsPlugin({
      compress: { warnings: false },
    })
  );
}
```

Take a note that there are many more options you can pass to **UglifyJsPlugin**. You can find them the [uglifyjs-webpack-plugin repo README](https://github.com/webpack-contrib/uglifyjs-webpack-plugin#uglifyoptions).
With compression setup in place, **Webpack** will build compressed bundles just **Asset Pipeline** does.

### Adding file names manifest

In order to teach **Rails** how to load generated bundle in **production** environment, we need to map bundle names to corresponding generated files. I used **StatsWriterPlugin** for this purpose but it writes mush more information than simple name mapping. I chose it because I was planning to use that additional information in future, so if you don't need it, you are free to use something more simple:

```javascript
if (process.env.NODE_ENV == 'production') {
  ...
  config.plugins.push(
    new StatsWriterPlugin({ filename: 'webpack_stats.json' })
  );
}
```
Note that `filename` option is relative to `output.path`, so our *webpack_stats.json* will be always generated in *public/assets* directory.

### Loading bundles on the page

Once we got everything in place all that's left is to load our **entry** bundles on our webpage. **React on Rails** offers some magic helpers for that, i.e. *env_javascript_include_tag*, see gem's [helpers file](https://github.com/shakacode/react_on_rails/blob/6.10.0/app/helpers/react_on_rails_helper.rb) for details. These helpers inspired me to create my own helper class.

Here's a general idea: in **non-production** environments we refer to the bundles directly by their names since they do not contain hashes. In this case we don't need any names mapping at all. For **production** environment we parse generated *public/assets/webpack_stats.json* and store resulting hash in **Rails** configuration to avoid reading manifest form the file on every request since this is much slower.

Let's start from reading *webpack_stats.json*. Because we only need it in **production**, we can assume that generated bundles will never change after **Rails** startup (until next restart) which means we can use an **initializer** do read the file and store its content to **Rails** configuration:

```ruby
# config/initilizers/webpack_assets.rb

# Read Webpack chunk assets manifest, generated by webpack-stats-plugin in "public/assets" directory,
# if file exists. If not - consider build as development and leave "webpack_assets" setting to equal nil.
# Write content of its "assetsByChunkName" entry to "webpack_assets" setting in Rails configuration,
# so "webpack_asset_tag" helper can access chunk file names to to generate <script> tags.
asset_stats = Rails.root.join('public', 'assets', 'webpack_stats.json')

if File.exist?(asset_stats)
  stats_data = JSON.parse(File.read(asset_stats)).with_indifferent_access
  raise 'Webpack stats does not contain "assetsByChunkName" entry' unless stats_data[:assetsByChunkName]

  Rails.configuration.webpack_assets = stats_data[:assetsByChunkName]
end
```

Obviously `Rails.configuration.webpack_assets` will be present only in **production** since we adding **StatsWriterPlugin** only for this environment. In non-production environments this configuration entry will be `nil`. Once we created this initializer, we can implement our helpers for **JS** and **CSS** tags:

```ruby
# app/helpers/application_helper.rb

module ApplicationHelper
  ...

  # Inserts JavaScript tag for hot asset by given bundle name for
  # given react_on_rails environment. If react_on_rails environment is
  # different, inserts nothing.
  #
  # *Arguments*:
  # - +name+ {String} Name of webpack bundle (entry point or named chunk created by Code Splitting)
  # - +asset_env_type+ {Symbol} Type of react_on_rails environment for which tag will be included (:hot or :static)
  def webpack_env_hot_asset_tag(name, asset_env_type)
    HelperClasses::WebpackAssetTagRenderer.new(self).hot_asset_tag(name, asset_env_type)
  end

  # Inserts JavaScript tag for compiled asset by given bundle name for
  # given react_on_rails environment. If react_on_rails environment is
  # different, inserts nothing.
  #
  # *Arguments*:
  # - +name+ {String} Name of webpack bundle (entry point or named chunk created by Code Splitting)
  # - +asset_env_type+ {Symbol} Type of react_on_rails environment for which tag will be included (:hot or :static)
  def webpack_env_compiled_javascript_tag(name, asset_env_type)
    HelperClasses::WebpackAssetTagRenderer.new(self).compiled_asset_tag(name, 'js', asset_env_type)
  end

  # Inserts stylesheet tag for compiled asset by given chunk name for
  # given react_on_rails environment. If react_on_rails environment is
  # different, inserts nothing.
  #
  # *Arguments*:
  # - +name+ {String} Name of webpack bundle (entry point or named chunk created by Code Splitting)
  # - +asset_env_type+ {Symbol} Type of react_on_rails environment for which tag will be included (:hot or :static)
  def webpack_env_compiled_stylesheet_tag(name, asset_env_type)
    HelperClasses::WebpackAssetTagRenderer.new(self).compiled_asset_tag(name, 'css', asset_env_type)
  end
end
```

As you can see all these helpers do not contain much logic. They just create new object of `WebpackAssetTagRenderer` class by passing it current `ActionView::Template` instance so that renderer instance will be able to write directly to current template's buffer. Putting all logic to an isolated class allows to write unit tests for the class itself instead of tons [rspec-rails helper specs](https://github.com/rspec/rspec-rails#helper-specs). It also correctly hides private methods so they will not be accessible by the template. Here how does it lool like:

```ruby
# app/helpers/helper_classes/webpack_asset_tag_renderer.rb

module HelperClasses
  class WebpackAssetTagRenderer
    # Public constructor.
    #
    # *Arguments*:
    # - +template+ {ActionView::Template} Template instance which buffer will be used for output
    def initialize(template)
      @template = template
    end

    # Inserts JavaScript tag for hot asset by given chunk name for
    # given react_on_rails environment. If react_on_rails environment is
    # different, inserts nothing.
    #
    # *Arguments*:
    # - +name+ {String} Name of webpack bundle chunk (entry point or named chunk created by Code Splitting)
    # - +asset_env_type+ {Symbol} Type of react_on_rails environment for which tag will be included (:hot or :static)
    def hot_asset_tag(name, asset_env_type)
      return unless asset_env_type == current_asset_env_type
      file_url = File.join(Rails.configuration.webpack_dev_server_url, "#{name}-bundle.js")
      @template.javascript_include_tag file_url
    end

    # Inserts asset tag of given type (extension) for compiled asset by given
    # chunk name for given react_on_rails environment. If react_on_rails
    # environment is different, inserts nothing. Asset URL will depend on build
    # environment.
    #
    # *Arguments*:
    # - +name+ {String} Name of webpack bundle chunk (entry point or named chunk created by Code Splitting)
    # - +extension+ {String} Asset extension ('js' or 'css')
    # - +asset_env_type+ {Symbol} Type of react_on_rails environment for which tag will be included (:hot or :static)
    def compiled_asset_tag(name, extension, asset_env_type)
      return unless asset_env_type == current_asset_env_type

      chunks = Rails.configuration.webpack_assets

      # If this is production buils, chunks have hashes and names mapping:
      return production_asset_tag(chunks, name, extension) if chunks

      # If this is development build and chunks have no hashes in their names:
      development_asset_tag(name, extension)
    end

    private

    # Detects if want to use Webpack Dev Server or just static assets.
    #
    # *Returns*:
    # {Symbol} :hot if Webpack Dev Server is used else :static
    def current_asset_env_type
      use_hot_reloading = ENV['REACT_ON_RAILS_ENV'] == 'HOT'
      use_hot_reloading ? :hot : :static
    end

    # Inserts asset tag of given type (extension) for compiled asset by given
    # chunk name for given react_on_rails environment. If react_on_rails
    # environment is different, inserts nothing. Asset URL will contain hash
    # and be taken from Webpack stats manifest.
    #
    # *Arguments*:
    # - +chunks+ {Hash} Contents of Webpack stats manifest
    # - +name+ {String} Name of webpack bundle chunk (entry point or named chunk created by Code Splitting)
    # - +extension+ {String} Asset extension ('js' or 'css')
    def production_asset_tag(chunks, name, extension)
      unless chunks[name]
        raise "There is no chunk files for entry point with name '#{name}'' in Rails.configuration.webpack_assets"
      end

      extension_prefixed_by_dot = ".#{extension}"

      # Manifest key-value pairs can look like:
      # app: ['app-bundle-chunkhash.js', 'app-bundle-chunkhash.css']
      # as well as:
      # some_chunk: 'some_chunk-bundle-chunkhash.js'
      asset_file = if chunks[name].instance_of?(Array)
                     chunks[name].find { |asset_file_name| asset_file_name.end_with? extension_prefixed_by_dot }
                   else
                     chunks[name]
                   end

      asset_file_url = "/assets/#{asset_file.sub(extension_prefixed_by_dot, '')}"

      case extension
      when 'js'
        @template.javascript_include_tag asset_file_url
      when 'css'
        @template.stylesheet_link_tag asset_file_url, media: 'all'
      end
    end

    # Inserts asset tag of given type (extension) for compiled asset by given
    # chunk name for given react_on_rails environment. If react_on_rails
    # environment is different, inserts nothing. Asset URL will be generated
    # based on chunk names convention.
    #
    # *Arguments*:
    # - +name+ {String} Name of webpack bundle chunk (entry point or named chunk created by Code Splitting)
    # - +extension+ {String} Asset extension ('js' or 'css')
    def development_asset_tag(name, extension)
      file_name = "#{name}-bundle.#{extension}"
      file_path = Rails.root.join('public', 'assets', file_name.to_s)

      unless File.exist?(file_path)
        raise "Can't Webpack chunk file with name '#{file_name}' in development assests mode"
      end

      # Add script tag with file last update time stamp as a parameter, like old version of sp_rockets did:
      file_update_timestamp = File.new(file_path).mtime.to_i
      extension_prefixed_by_dot = ".#{extension}"
      file_name_without_extension = file_name.sub(extension_prefixed_by_dot, '')
      file_url = "/assets/#{file_name_without_extension}?#{file_update_timestamp}"

      case extension
      when 'js'
        @template.javascript_include_tag file_url
      when 'css'
        @template.stylesheet_link_tag file_url, media: 'all'
      end
    end
  end
end
```

The listing contains a lot of comments so general idea of how it works should be clean enough. The class has some specific things that you might find not useful for your own projects but it serves its purpose well.

There is some difference in tags generation logic against how **React on Rails** helpers do that: instead of passing everything to one **JS** helper, I created specific helper for **hot reloading** mode and for **static assets**. Each of them generates `<script>` tag only for corresponding type of *REACT_ON_RAILS_ENV* or does nothing if environment does not match. To understand this better, let's look at the final part of our customization - application layout:

```erb
<!DOCTYPE html>
<html>
  <head>
    ...
    <%= webpack_env_compiled_stylesheet_tag 'app', :static %>
    <%= webpack_env_hot_asset_tag 'app', :hot %>
    <%= webpack_env_compiled_javascript_tag 'app', :static %>
    <%= yield :asset_tags if content_for?(:asset_tags) %>
  </head>
  <body>
    ...
  </body>
</html>
```

So for `REACT_ON_RAILS_ENV=HOT` it will create only one `<script ...>`tag pointing to **Webpack Dev Server**'s asset. `<link rel="stylesheet" ...>` tag will not be created since **Dev Server** will manage styles for us.

In case when *REACT_ON_RAILS_ENV* is not set, our template will be rendered with `<script ...>` tag pointing to compiled static **JS** file and `<link rel="stylesheet" ...>` tag pointing to compile **CSS**.

The only one final thing that's left to do is to remove that rake task which creates symlinks to files "digested" by **Asset Pipline**. We don't need it anymore.

## Conclusion

With the solution above we do not have to care of double "digesting" of the bundles and assets generated by [Webpack file-loader](https://webpack.js.org/loaders/file-loader/) - everything will have correct hashes generated by **Webpack** in filenames and everything will be generated to the same directory - *public/assets*. And you do not need solutions like [this](https://github.com/shakacode/react_on_rails/blob/6.10.0/docs/additional-reading/rails-assets-relative-paths.md).

Moreover you can still use non-webpack assets with **Asset Pipeline** - just use regular **Rails** tag helpers along with custom ones described above. I used this approach in few projects and some of them work stable in production for more than a year or two.

But before trying to customize your project like that make sure you really can't use the last version of **React on Rails** with **Webpacker** - **Sahakacode** team already provides much better solution out of the box!
