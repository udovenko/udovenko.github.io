---
layout: post
title:  "Using dynamic imports with old versions of React on Rails"
date:   2018-03-26 11:16:01 +1100
categories: react-on-rails
---

> At the moment of writing this post, [React on Rails gem](https://github.com/shakacode/react_on_rails) has an integration with [Webpacker](https://github.com/rails/webpacker) and should work fine with [Webpack dynamic imports](https://webpack.js.org/guides/code-splitting/#dynamic-imports) so if you are able to swith to the lates version of **React on Rails** - just go ahead, follow gem's official docs and skip this article.

### The History

But if you're still here and reading this, let's return few years back, to the moment when **React on Rails** was using [Rails Asset Pipeline](http://guides.rubyonrails.org/asset_pipeline.html) to fingerprint bundles generated by **Webpack** by including them to regular **Sprockets's** *application.js* and *application.css* files.

Why would you use that old version? Well, usually it can happen when you are clocked by some other old gems that produce dependency conflict with newer versions of **React on Rails** or you're simply use old version of **Rails** itself.

Here's how it was actually working:
1. **Webpack** was building **JS** and **CSS** the bundles to *app/assets/webpack* directory. Bundle files should have been named without any hashing by **Webpack**, like *client-bundle.js* and so on.
2. Those bundles were referenced in *app/assets/javascripts/application.js* by direcrtives like `//= require client-bundle` (and something like `@import 'client-bundle';` in *app/assets/stylesheets/application.scss*).
3. In **staging** environments these files were loading to the page by referencing them according to real names. **Asset Pipeline** was simply generating tags like `<script src="assets/client-bundle.js"></script>` and similar for **CCS**.
4. In **production** environments all scripts included in *app/assets/javascripts/application.js* were combined in in single file, compressed by **Uglifier** (or whatever else was set as a **JS** compiler), hashed according that file's **MD5** sum. As a result in production we were getting something like `<script src="/assets/application-908e25f4bf641868d8683022a5b62f54.js"></script>`. Something very similar was happening with **CSS** bundles, created by **Webpack**.

At point **3** and **4** I'm tending to repeat **Asset Pipeline** docs, which I generally don't like to do. So if you need some details about how all these works - just check official docs and [Sprockets](https://github.com/rails/sprockets) repo. There is also a pretty good explanation of what I'm trying to describe in old [README form React on Rails repo](https://github.com/shakacode/react_on_rails/tree/6.10.0#how-it-works).

### The Problem

Everything described above was working just fine if using **Dynamic Imports** was not the case.

At the time where we traveled to in previous section (few years ago), the version of **Webpack** was **1.x** or **2.x** and
we used `require.ensure()` construction instead of `import()` syntax to dynamically load code chunks. Let's mean both syntaxes by **Dynamic Imports** for clarity - they intended to do about the same thing.

So what's the actually problem? The problem is that in our particular case both **Webpack** and **Asset Pipeline** interfere each other trying to solve the same problem - bypassing browser's cache when sorce files were updated.

When **Webpack** builds the **entry** chunk that is responsible for dynamic loading of **children** (the chunks created by analyzing your split points i.e. `require.ensure()`), it embeds **children** chunk names into the result code. It means that **entry** chunk expects particular file to be available in your `config.output.publicPath`.

On the other hand, when files go through **Assets Pipeline** in production, their names change by adding **MD5** hashes. Which means **entry** chunk will unable **children** since they was renamed.

### Official solution

Of course [Shakacode team](http://www.shakacode.com/) was aware of everything I've just explained above. Even in early versions of **React on Rails** repo you can find good document about [code splitting](https://github.com/shakacode/react_on_rails/blob/6.10.0/docs/additional-reading/code-splitting.md) that describes the feature in details.
